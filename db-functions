#!/bin/bash

# Useful functions
UMASK=""
set_umask () {
	[ "$UMASK" == "" ] && UMASK="$(umask)"
	export UMASK
	umask 002
}

restore_umask () {
	umask $UMASK >/dev/null
}

# set up general environment
WORKDIR=$(mktemp -d /tmp/$(basename $0).XXXXXXXXXX)
LOCKS=()

script_lock() {
	local LOCKDIR="$TMPDIR/.scriptlock.$(basename $0)"
	if ! mkdir "$LOCKDIR" >/dev/null 2>&1 ; then
		local _owner="$(/usr/bin/stat -c %U $LOCKDIR)"
		echo "Error: Script $(basename $0) is already locked by $_owner." >&2
		exit 1
	else
		set_umask
		return 0
	fi
}

script_unlock() {
	local LOCKDIR="$TMPDIR/.scriptlock.$(basename $0)"
	if [ ! -d "$LOCKDIR" ]; then
		echo "Warning: Script $(basename $0) was not locked!" >&2
		restore_umask
		return 1
	else
		rmdir "$LOCKDIR"
		restore_umask
		return 0
	fi
}

cleanup() {
	local l
	local repo
	local arch

	trap - EXIT INT QUIT TERM
	for l in ${LOCKS[@]}; do
		repo=${l%.*}
		arch=${l#*.}
		if [ -d "$TMPDIR/.repolock.$repo.$arch" ]; then
			echo "Removing left over lock from $repo/$arch" >&2
			repo_unlock $repo $arch
		fi
	done
	if [ -d "$TMPDIR/.scriptlock.$(basename $0)" ]; then
		echo "Removing left over lock from $(basename $0)" >&2
		script_unlock
	fi
	rm -rf "$WORKDIR"
	[ "$1" ] && exit $1
}

abort() {
	echo 'Aborting...' >&2
	cleanup 0
}

die() {
	echo "$*" >&2
	cleanup 1
}

trap abort INT QUIT TERM
trap cleanup EXIT


#repo_lock <repo-name> <arch> [timeout]
repo_lock () {
	local LOCKDIR="$TMPDIR/.repolock.$1.$2"
	local _count
	local _trial
	local _timeout
	local _lockblock
	local _owner

	if [ $# -eq 2 ]; then
		_lockblock=true
		_trial=0
	elif [ $# -eq 3 ]; then
		_lockblock=false
		_timeout=$3
		let _trial=$_timeout/$LOCK_DELAY
	fi

	_count=0
	while [ $_count -le $_trial ] || $_lockblock ; do
		if ! mkdir "$LOCKDIR" >/dev/null 2>&1 ; then
			_owner="$(/usr/bin/stat -c %U $LOCKDIR)"
			echo "Warning: Repo $1-$2 is already locked by $_owner. Retrying in $LOCK_DELAY seconds..." >&2
		else
			LOCKS[${#LOCKS[*]}]="$1.$2"
			set_umask
			return 0
		fi
		sleep $LOCK_DELAY
		let _count=$_count+1
	done

	echo "Error: Repo $1-$2 is already locked by $_owner. Giving up!" >&2
	return 1
}

repo_unlock () { #repo_unlock <repo-name> <arch>
	local LOCKDIR="$TMPDIR/.repolock.$1.$2"
	if [ ! -d "$LOCKDIR" ]; then
		echo "Warning: Repo lock $1-$2 was not locked!" >&2
		restore_umask
		return 1
	else
		rmdir "$LOCKDIR"
		restore_umask
		return 0
	fi
}

# usage: _grep_pkginfo pkgfile pattern
_grep_pkginfo() {
	local _ret

	_ret="$(/usr/bin/bsdtar -xOqf "$1" .PKGINFO | /bin/grep -m 1 -E "$2" | /bin/sed 's|\w*\s*=\s*\(.*\)|\1|')"
	echo "$_ret"
}


# Get the package base or name as fallback
getpkgbase() {
	local _base

	_base="$(_grep_pkginfo "$1" "^pkgbase")"
	if [ -z "$_base" ]; then
		getpkgname "$1"
	fi

	echo "$_base"
}

# Get the package name
getpkgname() {
	local _name

	_name="$(_grep_pkginfo "$1" "^pkgname")"
	if [ -z "$_name" ]; then
		echo "Error: Package '$1' has no pkgname in the PKGINFO. Fail!" >&2
		exit 1
	fi

	echo "$_name"
}

# Get the pkgver-pkgrel of this package
getpkgver() {
	local _ver

	_ver="$(_grep_pkginfo "$1" "^pkgver")"
	if [ -z "$_ver" ]; then
		echo "Error: Package '$1' has no pkgver in the PKGINFO. Fail!" >&2
		exit 1
	fi

	echo "$_ver"
}

getpkgfile() {
	if [[ ${#} -ne 1 ]]; then
		echo 'Error: No canonical package found!' >&2
		exit 1
	elif [ ! -f "${1}" ]; then
		echo "Error: Package ${1} not found!" >&2
		exit 1
	fi

	echo ${1}
}

getpkgfiles() {
	local f
	if [ ! -z "$(echo ${@%\.*} | sed "s/ /\n/g" | sort | uniq -D)" ]; then
		echo 'Error: Duplicate packages found!'>&2
		exit 1
	fi

	for f in ${@}; do
		if  [ ! -f "${f}" ]; then
			echo "Error: Package ${f} not found!" >&2
			exit 1
		fi
	done

	echo ${@}
}

#check_pkg_arch pkgfile arch
check_pkg_arch () {
	local _arch
	_arch="$(_grep_pkginfo "$1" "^arch")"

	if [ -z "$_arch" ]; then
		echo "Error: Package '$1' has no arch in the PKGINFO. Fail!" >&2
		return 1
	fi
	if [ "$_arch" = "$2" ]; then
		return 0
	else
		return 1
	fi
}

get_repos_for_host() {
	if [ "$(hostname)" = "sigurd" ]; then
		echo "community community-testing"
	else
		echo "core extra testing"
	fi
}

get_pkgpool_for_host() {
	if [ "$(hostname)" = "sigurd" ]; then
		echo "packages/community"
	else
		echo "packages/arch"
	fi
}

#usage: chk_license ${license[@]}"
chk_license() {
	local l
	local allowed
	for l in "$@"; do
		l="$(echo $l | tr '[:upper:]' '[:lower:]')"
		for allowed in ${ALLOWED_LICENSES[@]}; do
			allowed="$(echo $allowed | tr '[:upper:]' '[:lower:]')"
			if [ "$l" = "$allowed" ]; then
				return 0
			fi
		done
	done

	return 1
}

pkgname_from_src() {
	local tmp
	local a
	tmp=${1##*/}
	tmp=${tmp%$SRCEXT}
	for a in ${ARCHES[@]}; do
		tmp=${tmp%-$a}
	done
	tmp=${tmp%-any}
	echo ${tmp%-*-*}
}

pkgver_from_src() {
	local tmp
	local a
	tmp=${1##*/}
	tmp=${tmp%$SRCEXT}
	for a in ${ARCHES[@]}; do
		tmp=${tmp%-$a}
	done
	tmp=${tmp%-any}
	echo $tmp | sed 's|.*-\(.*-.*\)$|\1|g'
}
